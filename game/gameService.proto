syntax = "proto3";

import "../api/model.proto";

message ChatMessage {
  User user = 1;
  string text = 2;
  Timestamp create_time = 3;
}

message ArtificialUser {
  string id = 1; // A randomly generated uuid.
  string name = 2;
}
// TODO - Add support for blank cards.

// Represents a real user or an artificial player in a game.
message Player {
  oneof identifier {
    User user = 1;
    ArtificialUser artificial_user = 2;
  }
  int32 score = 3;

  // When the player was added to the game. For real users this is
  // when the JoinGame RPC is called. For artificial players
  // this is when the AddArtificialPlayer RPC is called.
  Timestamp join_time = 4;
}

message GameInfo {
  string game_id = 1;
  string game_name = 2;
  int32 player_count = 3;
  int32 max_players = 4;
  User owner = 5;
  bool is_running = 6;
  // When the underlying game was created.
  Timestamp create_time = 7;
}

message GameView {
  enum Stage {
    NOT_RUNNING = 1;
    PLAY_PHASE = 2;
    JUDGE_PHASE = 3;
    ROUND_END_PHASE = 4;
  }

  message WhiteCardList {
    repeated WhiteCard cards = 1;
  }

  string name = 1;
  int32 max_players = 2;
  int32 max_score = 3;
  Stage stage = 4;
  repeated WhiteCard hand = 5;

  // All real and artificial players that are currently playing.
  // Guaranteed to be ordered by join_time.
  repeated Player players = 6;
  // All real and artificial players that joined while the game was running (any Stage other than NOT_RUNNING).
  // Guaranteed to be ordered by join_time.
  // These players will be automatically moved from queued_players to
  // players when either StopGame or StartNextRound RPCs are called.
  repeated Player queued_players = 7;
  repeated User banned_players = 8;
  string judge_id = 9;
  string owner_id = 10;
  map<string, WhiteCardList> white_played = 11;
  repeated WhiteCardList white_played_anonymous = 12;
  BlackCard current_black_card = 13;
  Player winner = 14;
  repeated ChatMessage chat_messages = 15;
  // When the underlying game was created.
  Timestamp create_time = 16;
}



// Returns all games that match the search criteria.
// Has no pagination, simply returns the entire list.
// Results are always ordered by create_time.
message SearchGamesRequest {
  // Filters games by name, i.e. games must contain the
  // exact text of the query in their name to match.
  string filter = 1;
  // The minimum number of slots
  // games must have available.
  int min_available_player_slots = 2;

  enum GameStageFilter {
    FILTER_NONE = 0; // Bypass game stage filter.
    FILTER_STOPPED = 1; // Filter all non-running games.
    FILTER_RUNNING = 2; // Filter all running games.
  }
  GameStageFilter game_stage_filter = 3;
}

message SearchGamesResponse {
  repeated GameInfo games = 1;
}

message CreateGameRequest {
  string user_id = 1; // The ID of the user creating the game.
  string game_name = 2;
  int32 max_players = 3;
  int32 max_score = 4;
  int32 hand_size = 5;
  repeated string cardpack_ids = 6;
}

message CreateGameResponse {
  GameView game = 1;
}

message StartGameRequest {
  string userId = 1; // Must be the ID of someone who owns the game that they are in.
}

message StartGameResponse {
  GameView game = 1;
}

message StopGameRequest {
  string userId = 1; // Must be the ID of someone who owns the game that they are in.
}

message StopGameResponse {
  GameView game = 1;
}

message JoinGameRequest {
  string user_id = 1; // The user who is joining a game.
  string game_name = 2; // The unique identifier of the game.
}

message JoinGameResponse {
  GameView game = 1;
}

message LeaveGameRequest {
  string user_id = 1; // The user who is leaving a game.
}

message LeaveGameResponse {
}

message KickUserRequest {
  string owner_id = 1;
  string troll_id = 1;
}

message KickUserResponse {
  GameView game = 1;
}

message PlayCardRequest {
  string user_id = 1;
  repeated string card_ids = 2;
}

message PlayCardResponse {
  GameView game = 1;
}

message UnplayCardRequest {
  string user_id = 1;
}

message UnplayCardResponse {
  GameView game = 1;
}

message JudgeCardRequest {
  string user_id = 1;
  string card_id = 2;
}

message JudgeCardResponse {
  GameView game = 1;
}

message StartNextRoundRequest {
  string user_id = 1;
}

message StartNextRoundResponse {
  GameView game = 1;
}

message AddArtificialPlayerRequest {
  // The name of the artificial player to add.
  // Name must not be used by any other
  // existing artificial players.
  string name = 1;
}

message AddArtificialPlayerResponse {
}

message RemoveArtificialPlayerRequest {
  string id = 1;
}

message RemoveArtificialPlayerResponse {
}

message SendMessageToGameRequest {
  string user_id = 1;
  string message_text = 2;
}

message SendMessageToGameResponse {
  GameView game = 1;
}

message GetGameViewRequest {
  string user_id = 1;
}

message GetGameViewResponse {
  GameView game = 1;
}

service GameService {
  rpc SearchGames (SearchGamesRequest) returns (SearchGamesResponse);
  rpc CreateGame (CreateGameRequest) returns (CreateGameResponse);
  rpc StartGame (StartGameRequest) returns (StartGameResponse);
  rpc StopGame (StopGameRequest) returns (StopGameResponse);
  rpc JoinGame (JoinGameRequest) returns (JoinGameResponse);
  rpc LeaveGame (LeaveGameRequest) returns (LeaveGameResponse);
  rpc KickUser (KickUserRequest) returns (KickUserResponse);
  rpc PlayCard (PlayCardRequest) returns (PlayCardResponse);
  rpc UnplayCard (UnplayCardRequest) returns (UnplayCardResponse);
  rpc JudgeCard (JudgeCardRequest) returns (JudgeCardResponse);
  rpc StartNextRound (StartNextRoundRequest) returns (StartNextRoundResponse);
  rpc AddArtificialPlayer (AddArtificialPlayerRequest) returns (AddArtificialPlayerResponse);
  rpc RemoveArtificialPlayer (RemoveArtificialPlayerRequest) returns (RemoveArtificialPlayerResponse);
  rpc SendMessageToGame (SendMessageToGameRequest) returns (SendMessageToGameResponse);
  rpc GetGameView (GetGameViewRequest) returns (GetGameViewResponse);
}
