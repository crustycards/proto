syntax = "proto3";

import "api/model.proto";
import "google/protobuf/empty.proto";
import "google/protobuf/timestamp.proto";

service GameService {
  rpc SearchGames (SearchGamesRequest) returns (SearchGamesResponse);
  rpc CreateGame (CreateGameRequest) returns (GameView);
  rpc StartGame (StartGameRequest) returns (GameView);
  rpc StopGame (StopGameRequest) returns (GameView);
  rpc JoinGame (JoinGameRequest) returns (GameView);
  rpc LeaveGame (LeaveGameRequest) returns (google.protobuf.Empty);
  rpc KickUser (KickUserRequest) returns (GameView);
  rpc BanUser (BanUserRequest) returns (GameView);
  rpc UnbanUser (UnbanUserRequest) returns (GameView);
  rpc PlayCards (PlayCardsRequest) returns (GameView);
  rpc UnplayCards (UnplayCardsRequest) returns (GameView);
  rpc VoteCard (VoteCardRequest) returns (GameView);
  rpc StartNextRound (StartNextRoundRequest) returns (GameView);
  rpc AddArtificialPlayer (AddArtificialPlayerRequest) returns (google.protobuf.Empty);
  rpc RemoveArtificialPlayer (RemoveArtificialPlayerRequest) returns (google.protobuf.Empty);
  rpc CreateChatMessage (CreateChatMessageRequest) returns (GameView);
  rpc GetGameView (GetGameViewRequest) returns (GameView);
}

// Returns all games that match the search criteria.
// Has no pagination, simply returns the entire list.
// Results are always ordered by create_time.
message SearchGamesRequest {
  // Filters games by name, i.e. games must contain the
  // exact text of the query in their name to match.
  string query = 1;

  // The minimum number of slots games must have available. Used to filter out games that are full
  // or nearly full.
  int32 min_available_player_slots = 2;

  enum GameStageFilter {
    FILTER_NONE = 0; // Bypass game stage filter.
    FILTER_STOPPED = 1; // Filter all non-running games.
    FILTER_RUNNING = 2; // Filter all running games.
  }
  GameStageFilter game_stage_filter = 3;
}

message SearchGamesResponse {
  repeated GameInfo games = 1;
}

message CreateGameRequest {
  // The id of the user creating the game.
  // This user will be the owner once the game is created.
  string user_id = 1;

  // Game configuration options.
  GameConfig game_config = 2;
}

message StartGameRequest {
  // The id of the user trying to start the game.
  // Must be the id of someone who owns the game that they are in.
  string user_id = 1;
}

message StopGameRequest {
  // The id of the user trying to stop the game.
  // Must be the id of someone who owns the game that they are in.
  string user_id = 1;
}

message JoinGameRequest {
  // The user who is joining a game.
  string user_id = 1;

  // The unique identifier of the game to join.
  string game_id = 2;
}

message LeaveGameRequest {
  // The user who is leaving a game.
  string user_id = 1;
}

message KickUserRequest {
  string owner_id = 1;
  string troll_id = 2;
}

message BanUserRequest {
  string owner_id = 1;
  string troll_id = 2;
}

message UnbanUserRequest {
  string owner_id = 1;
  string troll_id = 2;
}

message PlayCardsRequest {
  string user_id = 1;
  repeated string card_ids = 2;
}

message UnplayCardsRequest {
  string user_id = 1;
}

message VoteCardRequest {
  string user_id = 1;
  // The 0-based index of which set the judge votes for.
  int32 choice_index = 2;
}

message StartNextRoundRequest {
  string user_id = 1;
}

message AddArtificialPlayerRequest {
  // The name of the artificial player to add.
  string name = 1;
}

message RemoveArtificialPlayerRequest {
  string artificial_user_id = 1;
}

message CreateChatMessageRequest {
  // The chat message to create.
  ChatMessage chat_message = 1; // [(google.api.field_behavior) = REQUIRED].
}

message GetGameViewRequest {
  string user_id = 1;
}

message ChatMessage {
  // The user who sent the message.
  //
  // Required when creating (only user_id field is required).
  User user = 1;

  // The contents of the message.
  //
  // Required when creating.
  string text = 2;

  // When the message was created.
  google.protobuf.Timestamp create_time = 3;
}

message ArtificialUser {
  // A server-generated uuid.
  string id = 1;

  // The displayed name of the artificial user.
  // Since each artificial user has a unique id,
  // the name does not have to be unique.
  string name = 2;
}

// Represents a real user or an artificial player in a game.
message Player {
  oneof identifier {
    User user = 1;
    ArtificialUser artificial_user = 2;
  }

  // The number of rounds this player has won.
  int32 score = 3;

  // When the player was added to the game. For real users this is
  // when the JoinGame RPC is called. For artificial players
  // this is when the AddArtificialPlayer RPC is called.
  google.protobuf.Timestamp join_time = 4;
}

message BlankWhiteCard {
  // A server-generated uuid.
  string id = 1;
}

// Allows players to have regular white cards or blank cards.
message PlayableWhiteCard {
  oneof card {
    WhiteCard white_card = 1;
    BlankWhiteCard blank_card = 2;
  }
}

// Game list view used when users are browsing games.
message GameInfo {
  // A server-generated uuid.
  string game_id = 1;

  // Game configuration options.
  GameConfig config = 2;

  // The number of players currently in the game.
  // This does not include artificial players.
  int32 player_count = 3;

  // The current game owner.
  User owner = 5;

  // Whether the game is currently in progress.
  bool is_running = 6;

  // When the underlying game was created.
  google.protobuf.Timestamp create_time = 7;
}

message GameView {
  // The id of the game.
  string game_id = 1;

  // The displayed name of the game.
  string name = 2;

  // The maximum number of players that can be in the game at once.
  // Artificial players do not count towards this limit.
  // Value must be at least 3 and at most 100.
  int32 max_players = 3;
  int32 max_score = 4;

  enum Stage {
    STAGE_UNSPECIFIED = 0;
    NOT_RUNNING = 1;
    PLAY_PHASE = 2;
    JUDGE_PHASE = 3;
    ROUND_END_PHASE = 4;
  }
  
  Stage stage = 5;
  repeated PlayableWhiteCard hand = 6;

  // All real and artificial players that are currently playing.
  // Guaranteed to be ordered by join_time.
  repeated Player players = 7;

  // All real and artificial players that joined while the
  // game was running (any Stage other than NOT_RUNNING).
  // Guaranteed to be ordered by join_time.
  // These players will be automatically moved from queued_players to
  // players when either StopGame or StartNextRound RPCs are called.
  repeated Player queued_players = 8;

  // All users that have been banned from the game.
  // These users are unable to join the game.
  repeated User banned_players = 9;

  // The current judge for the round.
  // This might be empty if the game stage is NOT_RUNNING
  // (if there is a previous judge to show from the past game
  // then it will be filled, otherwise it will be empty).
  // If the game is in any other stage then this is always filled.
  // When the game stage is PLAY_PHASE or JUDGE_PHASE
  // it represents the current judge, and the judge does not change
  // when the stage is changed from JUDGE_PHASE to ROUND_END_PHASE.
  // Instead, it changes when the game stage changes from ROUND_END_PHASE to PLAY_PHASE.
  // Whenever a game is started, a new random judge is selected.
  User judge = 10;

  // The current owner of the game.
  // The game creator is the initial
  // owner, but if the current owner
  // leaves then ownership is transferred
  // to the next user who has been
  // in the game the longest.
  User owner = 11;

  // Contains cards played by
  // a single user for one round.
  // See the description for white_played
  // for details on how this is used
  // and when certain fields are filled.
  message WhiteCardsPlayed {
    // The user who played the cards.
    User user = 1;

    // The cards played by the user.
    repeated PlayableWhiteCard cards = 2;
  }

  // The white cards played this round.
  // Data contained is dependent on the game stage.
  // ----------------------------------------------
  // When the game stage is PLAY_PHASE, each repeated value
  // represents who has played this round. The 'user' field
  // is filled for each value so that players know who has
  // played, but the 'cards' field is empty so cards remain
  // anonymous until after the judge phase. Values are
  // in the order that players played.
  //
  // When the game stage is JUDGE_PHASE, this will contain
  // one value for each player that has played this round.
  // For each repeated value, the 'cards' property will be
  // filled but the 'user' property will be left empty and
  // the order of values randomized so users don't know who
  // submitted each card.
  //
  // When the game stage is ROUND_END_PHASE, this will
  // contain one value for every player that played in
  // the current round. For each repeated value, both
  // 'user' and 'cards' properties will be filled.
  // Values are in the same order as they were during
  // the judge phase.
  //
  // When the game stage is NOT_RUNNING, behavior is the same as ROUND_END_PHASE
  // except that the repeated field could contain no values. This happens if
  // the game was just created and there is no past round to show cards for.
  // Otherwise this will contain cards from the previous game
  // that just ended (or was stopped).
  repeated WhiteCardsPlayed white_played = 12;

  // The black card that's active for the current round.
  // This is empty if stage is NOT_RUNNING, otherwise
  // this will contain the current card.
  BlackCard current_black_card = 13;

  // Contains the winner of the most recent game.
  // This is only filled when the stage is NOT_RUNNING
  // and there is a winner to display. There is not
  // always a winner to display, such as if the game
  // was just created or if it was stopped
  // before someone won.
  Player winner = 14;

  // Chat messages sent by players in the game.
  // Contains, at most, the 100 most recent messages.
  repeated ChatMessage chat_messages = 15;

  // When the game was created.
  google.protobuf.Timestamp create_time = 16;
}